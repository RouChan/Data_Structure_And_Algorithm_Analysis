Chapter 2-Linear List
========
1. 对于顺序表的初始化，可将声明和定义分离，避免野指针无法判断问题；
2. 链表头的节点中，数据域可以存储关于链表的信息，例如节点数量等；
3. 返回值为地址时，若查找失败，则可返回`NULL`，并在主函数调用时，**判断是否调用成功。**
4. 清空链表`Clear()` -> 从第一个结点开始逐一删除；
5. 编写`enum StatusCode`作为函数操作状态码。
    ```C++
    enum StatusCode {SUCCESS, FAIL, UNDER_FLOW, OVER_FLOW,RANGE_ERROR, DUPLICATE_ERROR,
	NOT_PRESENT, ENTRY_INSERTED, ENTRY_FOUND, VISITED, UNVISITED};
    ```
6. **查找运算：**顺序表可以按照序号随机访问读取，单链表需要逐一移动，若查找失败，则返回`nullptr`；
7. **单链表插入运算：**若需要将新结点插入到表的第i个结点上，需要定位到位置为`(a-1)`的节点pos；
8. **单链表删除结点：**需要用一个tmp指针记录被删除结点的地址，便于前后结点结合之后的删除；
9. 顺序表**存储密度**大于线性表，若能确定线性表的大小，为了节约空间，宜用顺序表作为其存储结构；顺序表查找等**时间复杂**度也更低（可随机访问）；若频繁进行插入与删除操作，则宜采用链表作为存储结构；若表的插入和删除主要发生在表的首尾两端，可以给链表添加`rear`尾指针；
---

Chapter 3-Stack and Queue
========
-   **顺序栈的数据成员**
    -   `count` `maxSize` `array`
-   **链式栈的数据成员**
    -   `top` 栈顶指针
-   **(循环)顺序队列的数据成员**
    -   `(int)front`队头 `(int)rear`队尾 `maxSize` `array`
-   **链式队列的数据成员**
    -   `front`队头指针 `rear`队尾指针
## Stack
-   插入删除端为栈顶`Top`，另一端为栈底`Bottom`；
-   栈`a1`为栈底元素，`an`为栈顶元素；
-   **顺序栈**：利用一组连续地址的存储单元依次存放从栈底到栈顶的数据元素；
-   链式栈结点的`next`由`Top`指向`Bottom`；
-   栈的链式实现一般不使用头结点，即`a1`直接为栈底元素；
## Queue
-   **队列**：是只允许在一端插入，在另一端删除的线性表；
-   `a1`是队头结点，`an`是队尾结点。使用链表实现时，分别设置`头指针`和`尾指针`；
    ```c++
    front -> next = &a1;
    rear == &an;
    
    (front == rear) == (queue.Empty() == true); 
    ```
-   **链式队列**结点的`next`由`Front`指向`Rear`；
-   **循环队列**
    -   在入队、出队的操作中，可能造成顺序表的后部分溢出，但前半部分的顺序表为空，造成假溢现象，此时可以采用虚幻队列的方式进行解决；
    -   注意区分`front == rear`时空栈或满栈的判断；
---

Chapter 4-String
===========
-   **顺序串数据成员**
    -   `str`（存储串的头指针） `length`


-   块链存储表示
    -   串的数据元素是一个字符，因此使用链式存储结构保存串时，每个结点的指针域所占空间大于字符作占的空间，因此空间利用效率较低，引入块链存储表示；
    -   **块链存储**，每个结点存放若干个字符，减少链表中的结点数量，增大空间利用效率；
-   存储密度；
---

Chapter 5-Array and Generalized Table
=========
-   **对称矩阵、三角矩阵数据成员**
    -   `Elemt*` `n`(矩阵行数)


## Array&Matrix
-   高维数组在内存中的存储顺序（一段连续的、一维的内存空间）：
    ```c++
    // 行优先顺序存储类型
    a[0][0][0] ... a[0][0][n - 1] ... a[0][m - 1][n - 1] ... a[p - 1][m - 1][n - 1];
    ```
-   **矩阵 Matrix**可以描述为二维数组，**下标通常从`1`开始**，常用`a(i,j)`引用矩阵中第`i`行第`j`列的元素；
-   特殊矩阵
    -   值相同的元素或零元素在矩阵中按一定的规律分布；
    -   可以用特殊的方法进行存储和处理，以便提高空间和时间效率；
    -   包括对称矩阵、三角矩阵、对角矩阵；
    -   保持行优先的存储顺序；
    -   单独开辟一个一维数组保存特殊矩阵的非零非规律部分映射；
-   对称矩阵
    -   方阵、`a(i,j) = a(j,i)`；
    -   只需要存储上三角或下三角的元素，且对称元素共享同一个存储空间，能节约一半的存储空间；
-   三角矩阵
    -   以主对角线划分，矩阵上三角矩阵（下三角均为常数）、下三角矩阵（上三角均为常数）；
    -   只需要存储上三角或下三角的元素和对应三角存储的常数；
-   对角矩阵
    -   除了主对角线和主对角线相邻两侧的若干条对角线伤的元素外，其余元素皆为零；
-   **稀疏矩阵：** 矩阵中非零元素个数远小于矩阵元素的总个数；
    -   稀疏因子`e=s/(m*n)`，`e<0.05`为稀疏矩阵，采用压缩存储方法节约存储空间；
    -   **三元组顺序表压缩方式**：以顺序存储结构来表示三元组表；
        ```c++
        struct Triple {
            int row, col, value;
        };
        
        class Matrix {
            Triple *element;
        };
        ```
        -   一个三元组`(i,j,a(i,j))`唯一确定了矩阵`A`的一个非零元，因此稀疏矩阵可由表示非零元的三元组及其行列数唯一确定；
        -   使用二维数组存储三元组数据`(row, column, value)`；
    -   矩阵转置见`Algorithm_Note.md`
## Generalized Table
